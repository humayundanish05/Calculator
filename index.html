 
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scientific Calculator + Grapher + Complex</title>
<style>
  :root{--bg:#0f1114;--panel:#15181c;--muted:#9aa3ad;--accent:#2fb6ff;--btn:#222629}
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef6;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
  .app{display:flex;gap:18px;padding:18px;box-sizing:border-box;height:100%}
  .left{width:420px;background:var(--panel);border-radius:12px;padding:14px;box-shadow:0 6px 30px rgba(0,0,0,.6);display:flex;flex-direction:column;gap:10px}
  .display{height:52px;background:#0b0c0d;border-radius:8px;padding:10px;font-family:monospace;font-size:18px;color:#dfe9f5;border:1px solid rgba(255,255,255,.03)}
  .kbd{display:flex;flex-wrap:wrap;gap:8px}
  button{background:var(--btn);border:none;color:#e6eef6;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  button.small{padding:6px 8px;font-size:13px}
  .row{display:flex;gap:8px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .right{flex:1;background:linear-gradient(180deg,#0b0c0d 0,#0f1215 100%);border-radius:12px;padding:14px;display:flex;flex-direction:column}
  #canvas{background:#08090a;border-radius:8px;width:100%;height:420px;display:block}
  .panel{background:linear-gradient(180deg,#0f1215,#0b0c0d);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,.03);display:flex;gap:10px;align-items:center}
  label{color:var(--muted);font-size:13px}
  input[type="text"], input[type="number"], select{background:#071015;border:1px solid rgba(255,255,255,.03);color:#dfe9f5;padding:8px;border-radius:6px;font-family:monospace}
  .info{color:var(--muted);font-size:13px}
  .small{font-size:13px;color:var(--muted)}
  .modes button.active{outline:2px solid rgba(47,182,255,.18)}
  .legend{display:flex;gap:10px;align-items:center}
  .dot{width:12px;height:12px;border-radius:50%}
</style>
</head>
<body>
<div class="app">
  <div class="left">
    <div class="display" id="display" contenteditable="false"></div>

    <div class="kbd">
      <div class="row">
        <button onclick="press('C')">C</button>
        <button onclick="press('back')">⌫</button>
        <button onclick="press('(')">(</button>
        <button onclick="press(')')">)</button>
        <button onclick="press('^')">^</button>
      </div>

      <div class="row">
        <button onclick="press('7')">7</button>
        <button onclick="press('8')">8</button>
        <button onclick="press('9')">9</button>
        <button onclick="press('/')">÷</button>
        <button onclick="press('sqrt(')">√</button>
      </div>

      <div class="row">
        <button onclick="press('4')">4</button>
        <button onclick="press('5')">5</button>
        <button onclick="press('6')">6</button>
        <button onclick="press('*')">×</button>
        <button onclick="press('pow(')">pow</button>
      </div>

      <div class="row">
        <button onclick="press('1')">1</button>
        <button onclick="press('2')">2</button>
        <button onclick="press('3')">3</button>
        <button onclick="press('-')">−</button>
        <button onclick="press('!')">!</button>
      </div>

      <div class="row">
        <button onclick="press('0')">0</button>
        <button onclick="press('.')">.</button>
        <button onclick="evaluate()" style="flex:1;background:var(--accent)">=</button>
        <button onclick="press('+')">+</button>
      </div>

      <div class="row">
        <button onclick="press('sin(')">sin</button>
        <button onclick="press('cos(')">cos</button>
        <button onclick="press('tan(')">tan</button>
        <button onclick="press('log(')">log</button>
        <button onclick="press('exp(')">e^x</button>
      </div>

      <div class="row">
        <button onclick="press('sinh(')">sinh</button>
        <button onclick="press('cosh(')">cosh</button>
        <button onclick="press('tanh(')">tanh</button>
        <button onclick="press('PI')">π</button>
        <button onclick="press('E')">e</button>
      </div>

      <div class="row">
        <button onclick="press('i')">i</button>
        <button onclick="press('conj(')">conj</button>
        <button onclick="press('abs(')">abs</button>
        <button onclick="press('arg(')">arg</button>
        <button onclick="press('complex(')">complex()</button>
      </div>
    </div>

    <div class="panel" style="justify-content:space-between">
      <div class="controls">
        <label class="small">DEG <input id="degToggle" type="checkbox" onchange="setDeg(this.checked)"></label>
        <button class="small" onclick="storeMemory()">M+</button>
        <button class="small" onclick="recallMemory()">MR</button>
        <button class="small" onclick="clearMemory()">MC</button>
      </div>
      <div class="info" id="memInfo">Memory: 0</div>
    </div>

    <div class="panel" style="flex-direction:column;gap:8px">
      <div style="display:flex;gap:8px;align-items:center">
        <label class="small">Complex calculator</label>
        <input id="complexExpr" type="text" placeholder="e.g. (3+2i)*(1-4i)" style="flex:1"/>
        <button onclick="computeComplex()" class="small">Calc</button>
      </div>
      <div class="small" id="complexResult">Result:</div>
    </div>
  </div>

  <div class="right">
    <div class="panel" style="align-items:center">
      <div style="flex:1;display:flex;gap:8px;align-items:center">
        <label>f(x) =</label>
        <input id="fnInput" type="text" placeholder="Use x, Math functions, or Complex(...) and i" style="flex:1;font-family:monospace" value="sin(x)"/>
        <button onclick="plot()" style="background:var(--accent)">Plot</button>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <label class="small">Mode</label>
        <div class="modes">
          <button onclick="setPlotMode('real')" id="mReal" class="small active">Real</button>
          <button onclick="setPlotMode('imag')" id="mImag" class="small">Imag</button>
          <button onclick="setPlotMode('mag')" id="mMag" class="small">|z|</button>
          <button onclick="setPlotMode('phase')" id="mPhase" class="small">arg</button>
        </div>
      </div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="panel" style="justify-content:space-between">
      <div style="display:flex;gap:10px;align-items:center">
        <label class="small">Domain</label>
        <input id="xmin" type="number" value="-10" style="width:80px"/>
        <input id="xmax" type="number" value="10" style="width:80px"/>
        <label class="small">Samples</label>
        <input id="samples" type="number" value="800" style="width:80px"/>
      </div>

      <div class="legend">
        <div style="display:flex;flex-direction:column;align-items:flex-end">
          <div class="small">Trace</div>
          <div class="small">Grid</div>
        </div>
        <div style="display:flex;flex-direction:column;gap:8px">
          <div style="display:flex;gap:8px;align-items:center"><div class="dot" id="dotTrace" style="background:var(--accent)"></div><div class="small">f(x)</div></div>
          <div style="display:flex;gap:8px;align-items:center"><div class="dot" style="background:#28323a"></div><div class="small">grid</div></div>
        </div>
      </div>
    </div>

    <div class="panel" style="margin-top:10px;justify-content:space-between">
      <div class="small">Use x. For complex use Complex(a,b) or i. Examples: sin(x), Complex(cos(x),sin(x)), (x+1i)^2</div>
      <div style="display:flex;gap:8px">
        <button onclick="zoom(0.8)" class="small">Zoom -</button>
        <button onclick="zoom(1.25)" class="small">Zoom +</button>
        <button onclick="resetView()" class="small">Reset</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ------------------ Complex class ------------------ */
class Complex {
  constructor(re=0, im=0){ this.re = +re; this.im = +im; }
  static from(x){ if (x instanceof Complex) return x; if (typeof x === 'number') return new Complex(x,0); return x; }
  add(o){ o=Complex.from(o); return new Complex(this.re+o.re,this.im+o.im); }
  sub(o){ o=Complex.from(o); return new Complex(this.re-o.re,this.im-o.im); }
  mul(o){ o=Complex.from(o); return new Complex(this.re*o.re - this.im*o.im, this.re*o.im + this.im*o.re); }
  div(o){ o=Complex.from(o); const d=o.re*o.re+o.im*o.im; return new Complex((this.re*o.re+this.im*o.im)/d,(this.im*o.re - this.re*o.im)/d); }
  abs(){ return Math.hypot(this.re,this.im); }
  arg(){ return Math.atan2(this.im,this.re); }
  conj(){ return new Complex(this.re,-this.im); }
  exp(){ const e = Math.exp(this.re); return new Complex(e*Math.cos(this.im), e*Math.sin(this.im)); }
  log(){ return new Complex(Math.log(this.abs()), this.arg()); }
  pow(o){
    o = Complex.from(o);
    // use e^{o * log(this)}
    return this.log().mul(o).exp();
  }
  toString(){ const r = this.re.toFixed(6); const i = this.im.toFixed(6); if (Math.abs(this.im) < 1e-12) return `${(+r).toString()}`; if (Math.abs(this.re) < 1e-12) return `${(+i).toString()}i`; return `${(+r)}${this.im>=0?'+':''}${(+i)}i`; }
}

/* ------------------ Utilities & evaluator ------------------ */
let degMode = false;
let memory = 0;
const displayEl = document.getElementById('display');
function setDeg(checked){ degMode = checked; }

function press(txt){
  if (txt === 'C'){ displayEl.textContent=''; return; }
  if (txt === 'back'){ displayEl.textContent = displayEl.textContent.slice(0,-1); return; }
  displayEl.textContent += txt;
}

function storeMemory(){
  try{ memory += evaluateExpressionToNumber(displayEl.textContent); updateMem(); }catch(e){ alert('mem err'); }
}
function recallMemory(){ displayEl.textContent += memory; }
function clearMemory(){ memory = 0; updateMem(); }
function updateMem(){ document.getElementById('memInfo').textContent = 'Memory: '+memory; }

/* Convert user expression into a safe JS expression using Math and Complex */
function sanitize(expr){
  // basic replacements: ^ -> Math.pow, constants PI, E, i -> Complex(0,1)
  expr = expr.replace(/([0-9])\s*\^/g,'$1 ^'); // keep caret to handle below
  expr = expr.replace(/\^/g, 'Math.pow');
  expr = expr.replace(/\bPI\b/g, 'Math.PI');
  expr = expr.replace(/\bE\b/g, 'Math.E');
  // factorial notation n! replaced with factorial(n)
  expr = expr.replace(/([0-9\.]+)!/g, 'factorial($1)');
  // allow user to write 3i or 2.5i
  expr = expr.replace(/([0-9\.]+)i\b/g, 'new Complex(0,$1)');
  // standalone i -> new Complex(0,1)
  expr = expr.replace(/\bi\b/g, 'new Complex(0,1)');
  // map trig to version that respects deg/rad via wrapper functions below
  return expr;
}

function factorial(n){
  n = Math.floor(+n);
  if (n < 0) return NaN;
  let r=1; for(let i=2;i<=n;i++) r*=i; return r;
}

/* wrapper functions for trig that handle deg/rad and accept numbers or Complex */
function wrapTrigFn(name){
  return function(x){
    // if x is Complex: use complex evaluation via polar/exponential or call series via Complex methods
    if (x instanceof Complex){
      // use formula via exp: sin(z) = (e^{iz}-e^{-iz})/(2i)
      const i = new Complex(0,1);
      if (name==='sin'){
        return i.mul(x).exp().sub(i.mul(x).exp().pow(-1)).div(new Complex(0,2)); // approximate using pow(-1) not defined; fallback
      }
      // fallback numeric on real/imag components (simple handling omitted)
      return x; // coarse fallback
    } else {
      let val = +x;
      if (degMode) val = val * Math.PI / 180;
      if (name==='sin') return Math.sin(val);
      if (name==='cos') return Math.cos(val);
      if (name==='tan') return Math.tan(val);
      if (name==='sinh') return Math.sinh(val);
      if (name==='cosh') return Math.cosh(val);
      if (name==='tanh') return Math.tanh(val);
    }
  }
}

/* create evaluation function for expression. It returns number or Complex.
   We expose Math, Complex class, helper functions, and x variable.
*/
function makeEvaluator(expr){
  const safe = sanitize(expr);
  const wrapped = `
    "use strict";
    const Math = this.Math;
    const Complex = this.Complex;
    const factorial = this.factorial;
    const sin = this.wrap.sin;
    const cos = this.wrap.cos;
    const tan = this.wrap.tan;
    const sinh = this.wrap.sinh;
    const cosh = this.wrap.cosh;
    const tanh = this.wrap.tanh;
    const pow = Math.pow;
    const exp = Math.exp;
    const log = Math.log;
    return (function(x){
      try{
        return (${safe});
      }catch(e){ return NaN; }
    });
  `;
  const ctx = { Math: Math, Complex: Complex, factorial: factorial, wrap:{ sin:wrapTrigFn('sin'), cos:wrapTrigFn('cos'), tan:wrapTrigFn('tan'), sinh:wrapTrigFn('sinh'), cosh:wrapTrigFn('cosh'), tanh:wrapTrigFn('tanh') } };
  // Use Function constructor with .call bound context to minimize global leakage
  const fnFactory = new Function(wrapped);
  return fnFactory.call(ctx);
}

function evaluateExpressionToNumber(expr){
  // try plain eval for simple numeric expressions using allowed mappings
  const f = makeEvaluator(expr);
  const v = f(0);
  if (v instanceof Complex) {
    if (!isNaN(v.re)) return v.re;
    throw new Error('not numeric');
  }
  return v;
}

function evaluate(){
  try{
    const f = makeEvaluator(displayEl.textContent || '0');
    const v = f(0);
    displayEl.textContent = (v instanceof Complex) ? v.toString() : String(v);
  }catch(e){
    displayEl.textContent = 'Error';
  }
}

/* ------------------ Complex calculator ------------------ */
function computeComplex(){
  const s = document.getElementById('complexExpr').value;
  try{
    const f = makeEvaluator(s);
    const v = f(0);
    document.getElementById('complexResult').textContent = 'Result: ' + ((v instanceof Complex)? v.toString() : String(v));
  }catch(e){
    document.getElementById('complexResult').textContent = 'Result: Error';
  }
}

/* ------------------ Plotting ------------------ */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let plotMode = 'real';
let view = {xmin:-10,xmax:10,ymin:-6,ymax:6};
function resizeCanvas(){ canvas.width = canvas.clientWidth * devicePixelRatio; canvas.height = canvas.clientHeight * devicePixelRatio; ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); drawGrid(); }
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function setPlotMode(m){
  plotMode = m;
  ['mReal','mImag','mMag','mPhase'].forEach(id=>document.getElementById(id).classList.remove('active'));
  if(m==='real') document.getElementById('mReal').classList.add('active');
  if(m==='imag') document.getElementById('mImag').classList.add('active');
  if(m==='mag') document.getElementById('mMag').classList.add('active');
  if(m==='phase') document.getElementById('mPhase').classList.add('active');
  plot();
}

function drawGrid(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  // background
  ctx.fillStyle = '#050607'; ctx.fillRect(0,0,w,h);
  // grid lines
  ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.lineWidth=1;
  const gx = niceStep((view.xmax-view.xmin)/10);
  const gy = niceStep((view.ymax-view.ymin)/8);
  for(let x = Math.ceil(view.xmin/gx)*gx; x<=view.xmax; x+=gx){
    const px = sx(x);
    ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,h); ctx.stroke();
  }
  for(let y = Math.ceil(view.ymin/gy)*gy; y<=view.ymax; y+=gy){
    const py = sy(y);
    ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(w,py); ctx.stroke();
  }
  // axes
  ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1.4;
  // x axis
  if(view.ymin<0 && view.ymax>0){ ctx.beginPath(); ctx.moveTo(0,sy(0)); ctx.lineTo(w,sy(0)); ctx.stroke(); }
  // y axis
  if(view.xmin<0 && view.xmax>0){ ctx.beginPath(); ctx.moveTo(sx(0),0); ctx.lineTo(sx(0),h); ctx.stroke(); }
}

function sx(x){ const w = canvas.clientWidth; return (x - view.xmin) / (view.xmax - view.xmin) * w; }
function sy(y){ const h = canvas.clientHeight; return h - (y - view.ymin) / (view.ymax - view.ymin) * h; }
function niceStep(range){ const pow = Math.pow(10,Math.floor(Math.log10(range))); const d = range / pow; if (d<1.5) return 1*pow; if (d<3) return 2*pow; if (d<7) return 5*pow; return 10*pow; }

function plot(){
  const expr = document.getElementById('fnInput').value || '0';
  const xmin = parseFloat(document.getElementById('xmin').value);
  const xmax = parseFloat(document.getElementById('xmax').value);
  const samples = Math.max(100, Math.min(2000, parseInt(document.getElementById('samples').value)));
  view.xmin = xmin; view.xmax = xmax;
  // attempt to auto-range y by sampling
  const f = makeEvaluator(expr);
  const xs = [];
  const vals = [];
  let ymin=Infinity,ymax=-Infinity;
  for(let i=0;i<samples;i++){
    const x = xmin + (xmax-xmin)*i/(samples-1);
    let v;
    try{ v = f(x); } catch(e){ v = NaN; }
    xs.push(x); vals.push(v);
    let y;
    if (v instanceof Complex){
      if (plotMode==='real') y = v.re;
      else if (plotMode==='imag') y = v.im;
      else if (plotMode==='mag') y = v.abs();
      else if (plotMode==='phase') y = v.arg();
    } else y = +v;
    if (!isFinite(y)) continue;
    ymin = Math.min(ymin,y); ymax = Math.max(ymax,y);
  }
  if (!isFinite(ymin) || !isFinite(ymax)){ ymin=-1; ymax=1; }
  // pad
  const pad = (ymax-ymin)*0.15 || 1;
  view.ymin = ymin - pad; view.ymax = ymax + pad;
  resizeCanvas();
  drawGrid();

  // draw trace
  ctx.lineWidth = 2; ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#2fb6ff';
  ctx.beginPath(); let started=false;
  for(let i=0;i<xs.length;i++){
    const x = xs[i], v = vals[i];
    let yval = NaN;
    if (v instanceof Complex){
      if (plotMode==='real') yval = v.re;
      else if (plotMode==='imag') yval = v.im;
      else if (plotMode==='mag') yval = v.abs();
      else if (plotMode==='phase') yval = v.arg();
    } else yval = +v;
    if (!isFinite(yval)){ started=false; continue; }
    const px = sx(x), py = sy(yval);
    if (!started){ ctx.moveTo(px,py); started=true; } else ctx.lineTo(px,py);
  }
  ctx.stroke();

  // draw points (optional: small)
  ctx.fillStyle = 'rgba(47,182,255,0.9)';
  for(let i=0;i<xs.length;i++){
    const x = xs[i], v = vals[i];
    let yval = NaN;
    if (v instanceof Complex){
      if (plotMode==='real') yval = v.re;
      else if (plotMode==='imag') yval = v.im;
      else if (plotMode==='mag') yval = v.abs();
      else if (plotMode==='phase') yval = v.arg();
    } else yval = +v;
    if (!isFinite(yval)) continue;
    const px = sx(x), py = sy(yval);
    ctx.fillRect(px-1,py-1,2,2);
  }
}

/* zoom/pan */
function zoom(factor){
  const cx = 0.5*(view.xmin+view.xmax); const rx = (view.xmax-view.xmin)/2;
  const ny = (view.ymax-view.ymin)/2;
  const newrx = rx/factor;
  view.xmin = cx - newrx; view.xmax = cx + newrx;
  // keep y centered
  const cy = 0.5*(view.ymin+view.ymax);
  view.ymin = cy - ny/factor; view.ymax = cy + ny/factor;
  plot();
}
function resetView(){ document.getElementById('xmin').value=-10; document.getElementById('xmax').value=10; document.getElementById('samples').value=800; plot(); }

/* init */
setPlotMode('real');
plot();

/* small UX: allow Enter to evaluate or plot */
document.getElementById('fnInput').addEventListener('keydown', e=>{ if(e.key==='Enter') plot(); });
document.getElementById('complexExpr').addEventListener('keydown', e=>{ if(e.key==='Enter') computeComplex(); });
document.addEventListener('keydown', e=>{ if(e.key==='Enter' && document.activeElement === displayEl) evaluate(); });

</script>
</body>
</html>

